# 키워드: `DFS` `Cut Edge`
46번 부턴 DFS의 꽃 컷 엣지가 나온다. 컷 엣지란 탐색할 경로가 너무 많을 경우 시간 복잡도가 급격하게 늘어나는 것을 방지하기 위한 방법이다. 바둑이 승차는 대표적인 컷엣지 문제인데 컷엣지를 사용하지 않을 경우 시간복잡도(O)를 살펴보자.

바둑이 승차는 이진 트리로 탐색할 경로는 1, 2, 4, 8,..., 2^n,... 으로 늘어난다.
따라서 O(2^n)의 시간 복잡도를 가진다. 

이를 막기 위해선 컷엣지를 사용해야 한다. 첫 번째로 쳐낼 수 있는 가지는 합이 한도를 초과했을 때이다. 두번째 코드의 경우

```python
        if sum <= c and sum > res:
        res = sum
```
과 같이 조건을 묶어 주었는데 이것은 마지막에 한번에 확인한다는 뜻이다. 하지만 이렇게 조건을 달 경우 중간에 이미 한도를 넘었음에도 불구하고 연산을 진행한다는 단점이 있다. 

```python
	if sum > res:
	  return
```
따라서 위와 같이 조건을 따로 빼주어 가지 치기를 하면 필요없는 연산을 하지 않아도 된다.

또 한가지 생각할 수 있는 것은 더 이상의 연산이 의미 없는 경우에도 가지 치기를 해줄 수 있다. 월드컵 승부차기를 생각해보면 총 5번의 승부차기에서 3라운드가 끝나고 상대팀은 3골을 넣었는데 우리팀은 한 골도 넣지 못했다면 그 승부차기는 이미 승부가 난 것이라고 본다. 

마찬가지로 다 남은 바둑이를 다 태워도 현재까지 나온 가장 무거운 무게를 이길 수 없다면 그 연산은 그만두는 것이 좋다. 이와 같은 조건은 tsum이라는 새로운 매개변수를 생성하면 해결할 수 있다. tsum에는 sum과 달리 계층이 내려갈때마다 계속 값을 더해준다. 그리고 전체 바둑이 무게의 합 total에서 tsum을 빼주면 sum에 더해질 가능성이 있는 값이 나온다. 그런데 가능성 값과 sum을 더했는데도 현재의 가장 큰 수(res)보다 작다면 가지 치기를 할 수 있다.

```python
    if sum + (total - tsum) < result:
        return
```
방금 얘기했던 내용은 위의 코드로 간단하게 구현할 수 있다!
우리는 두 번의 가지 치기를 통해 많은 연산을 줄일 수 있다. 연산을 줄여 시간복잡도를 개선하는 것은 코딩테스트뿐 아니라 실무에서도 중요한 작업이다!

